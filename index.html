<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Plinko Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            display: block;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
        }
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 5px;
        }
        #scoreDisplay {
            margin-top: 10px;
            font-weight: bold;
        }
        .slot-label {
            position: absolute;
            color: white;
            font-weight: bold;
            text-align: center;
            font-size: 14px;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="dropButton">Drop Chip</button>
        <button id="resetButton">Reset Score</button>
        <div id="scoreDisplay">Total Score: 0</div>
        <div id="lastScore"></div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

    <script>
        // Game variables
        let scene, camera, renderer, world;
        let chips = []; // Array to store multiple chips
        let chipBodies = []; // Array to store multiple chip bodies
        let isDropping = false;
        let totalScore = 0;
        let pegs = [];
        let pegBodies = [];
        let slotMeshes = [];
        let slotScores = [100, 50, 10, 10, 50, 100]; // Scores for slots
        let activeChips = 0; // Track number of active chips

        // Initialize the game
        function init() {
            // Create Three.js scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 20); // Move camera back for a bigger view
            camera.lookAt(0, 0, 0);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            // Create Cannon.js physics world
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0); // Earth gravity
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;
            world.defaultContactMaterial.contactEquationStiffness = 1e7; // Stiffer contacts for better stability
            world.defaultContactMaterial.contactEquationRelaxation = 3; // Relaxation for smoother interactions
            world.defaultContactMaterial.friction = 0.3; // Global friction
            world.defaultContactMaterial.restitution = 0.5; // Global bounciness

            // Create lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);

            // Create board
            createBoard();
            
            // Create pegs
            createPegs();
            
            // Create slots
            createSlots();

            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('dropButton').addEventListener('click', dropChip);
            document.getElementById('resetButton').addEventListener('click', resetScore);
            
            // Handle window resize for slot labels
            window.addEventListener('resize', updateSlotLabelPositions);

            // Start animation loop
            animate();
        }

        function createBoard() {
            // Create a backboard - make it bigger
            const boardGeometry = new THREE.BoxGeometry(18, 20, 0.5);
            const boardMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.7,
                metalness: 0.1
            });
            const board = new THREE.Mesh(boardGeometry, boardMaterial);
            board.position.z = -0.5;
            board.receiveShadow = true;
            scene.add(board);

            // Create board walls - make them bigger
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            
            // Left wall
            const leftWall = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 20, 1),
                wallMaterial
            );
            leftWall.position.set(-9, 0, 0);
            scene.add(leftWall);
            
            // Right wall
            const rightWall = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 20, 1),
                wallMaterial
            );
            rightWall.position.set(9, 0, 0);
            scene.add(rightWall);

            // Add physics for walls - make them bigger
            const wallShape = new CANNON.Box(new CANNON.Vec3(0.25, 10, 0.5));
            const wallMat = new CANNON.Material({
                friction: 0.1,
                restitution: 0.3
            });
            
            const leftWallBody = new CANNON.Body({ mass: 0, material: wallMat });
            leftWallBody.addShape(wallShape);
            leftWallBody.position.set(-9, 0, 0);
            world.addBody(leftWallBody);
            
            const rightWallBody = new CANNON.Body({ mass: 0, material: wallMat });
            rightWallBody.addShape(wallShape);
            rightWallBody.position.set(9, 0, 0);
            world.addBody(rightWallBody);
            
            // Add a back wall to prevent chips from falling behind
            const backWallBody = new CANNON.Body({ mass: 0 });
            const backWallShape = new CANNON.Box(new CANNON.Vec3(9, 10, 0.1));
            backWallBody.addShape(backWallShape);
            backWallBody.position.set(0, 0, -0.6);
            world.addBody(backWallBody);
            
            // Add a front constraint plane to keep chips from coming forward
            const frontConstraint = new CANNON.Body({ mass: 0 });
            const frontShape = new CANNON.Box(new CANNON.Vec3(9, 10, 0.1));
            frontConstraint.addShape(frontShape);
            frontConstraint.position.set(0, 0, 0.6);
            world.addBody(frontConstraint);
        }

        function createPegs() {
            const pegGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.5, 16); // Slightly bigger pegs
            const pegMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xCCCCCC,
                metalness: 0.8,
                roughness: 0.2
            });

            // Peg arrangement in rows - more rows and more pegs per row
            const rows = [
                { y: 8, count: 1, xOffset: 0 },
                { y: 6, count: 2, xOffset: 3 },
                { y: 4, count: 3, xOffset: 3 },
                { y: 2, count: 4, xOffset: 3 },
                { y: 0, count: 5, xOffset: 3 },
                { y: -2, count: 6, xOffset: 3 },
                { y: -4, count: 7, xOffset: 2.5 },
                { y: -6, count: 8, xOffset: 2.2 }
            ];

            rows.forEach(row => {
                for (let i = 0; i < row.count; i++) {
                    const x = (i * row.xOffset) - ((row.count - 1) * row.xOffset / 2);
                    
                    // Create visual peg
                    const peg = new THREE.Mesh(pegGeometry, pegMaterial);
                    peg.rotation.x = Math.PI / 2; // Rotate to stand upright
                    peg.position.set(x, row.y, 0);
                    peg.castShadow = true;
                    peg.receiveShadow = true;
                    scene.add(peg);
                    pegs.push(peg);

                    // Create physics body for peg
                    const pegShape = new CANNON.Cylinder(0.4, 0.4, 0.5, 16); // Match the visual size
                    const pegBody = new CANNON.Body({ 
                        mass: 0, // Static body
                        material: new CANNON.Material({
                            friction: 0.3,
                            restitution: 0.6 // Make pegs slightly more bouncy
                        })
                    });
                    pegBody.addShape(pegShape);
                    pegBody.position.set(x, row.y, 0);
                    pegBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
                    world.addBody(pegBody);
                    pegBodies.push(pegBody);
                }
            });
        }

        function createSlots() {
            const slotWidth = 3; // Wider slots
            const slotDepth = 1;
            const slotHeight = 0.5;
            const totalSlots = 6;
            
            // Colors for slots based on scores
            const slotColors = [
                0xFF0000, // Red - 100
                0xFFA500, // Orange - 50
                0xFFFF00, // Yellow - 10
                0xFFFF00, // Yellow - 10
                0xFFA500, // Orange - 50
                0xFF0000  // Red - 100
            ];

            // Create slot boundaries for collision detection
            const slotBoundaries = [];
            
            for (let i = 0; i < totalSlots; i++) {
                const x = (i * slotWidth) - ((totalSlots - 1) * slotWidth / 2);
                
                // Create visual slot
                const slotGeometry = new THREE.BoxGeometry(slotWidth, slotHeight, slotDepth);
                const slotMaterial = new THREE.MeshStandardMaterial({ 
                    color: slotColors[i],
                    transparent: true,
                    opacity: 0.8
                });
                
                const slot = new THREE.Mesh(slotGeometry, slotMaterial);
                slot.position.set(x, -9, 0); // Lower position for bigger board
                slot.userData = { score: slotScores[i], index: i };
                scene.add(slot);
                slotMeshes.push(slot);

                // Add score text above each slot
                const scoreDiv = document.createElement('div');
                scoreDiv.className = 'slot-label';
                scoreDiv.id = 'slot-label-' + i;
                scoreDiv.innerHTML = slotScores[i];
                scoreDiv.style.width = '60px'; // Wider labels
                scoreDiv.style.fontSize = '18px'; // Bigger font
                scoreDiv.style.left = (window.innerWidth / 2) + (x * 40) - 30 + 'px';
                scoreDiv.style.top = (window.innerHeight / 2) + 270 + 'px'; // Adjusted position
                document.body.appendChild(scoreDiv);
                
                // Store slot boundaries for collision detection
                slotBoundaries.push({
                    minX: x - slotWidth/2,
                    maxX: x + slotWidth/2,
                    score: slotScores[i],
                    index: i
                });
                
                // Add invisible walls between slots to guide chips
                if (i < totalSlots - 1) {
                    const dividerX = x + slotWidth/2;
                    const dividerBody = new CANNON.Body({ mass: 0 });
                    const dividerShape = new CANNON.Box(new CANNON.Vec3(0.05, 0.5, 0.5));
                    dividerBody.addShape(dividerShape);
                    dividerBody.position.set(dividerX, -9, 0); // Adjusted position
                    world.addBody(dividerBody);
                }
            }

            // Create a bottom barrier to catch the chips
            const barrierShape = new CANNON.Box(new CANNON.Vec3(9, 0.25, 0.5)); // Wider barrier
            const barrierBody = new CANNON.Body({ 
                mass: 0,
                collisionResponse: true
            });
            barrierBody.addShape(barrierShape);
            barrierBody.position.set(0, -10, 0); // Lower position
            
            // Add a callback for when chips hit the bottom barrier
            barrierBody.addEventListener("collide", function(e) {
                const chipBody = e.body;
                if (chipBody && chipBody.userData && !chipBody.userData.scored) {
                    scoreChip(chipBody);
                }
            });
            
            world.addBody(barrierBody);
        }

        function createChip() {
            // Create visual chip
            const chipGeometry = new THREE.SphereGeometry(0.5, 32, 32); // Slightly bigger chips
            const chipMaterial = new THREE.MeshStandardMaterial({ 
                color: Math.random() * 0xffffff, // Random color for each chip
                metalness: 0.3,
                roughness: 0.4
            });
            
            const newChip = new THREE.Mesh(chipGeometry, chipMaterial);
            newChip.castShadow = true;
            
            // Add small random offset to x position for variability
            const xOffset = (Math.random() - 0.5) * 3; // Increased range for more variability
            newChip.position.set(xOffset, 9, 0); // Higher starting position
            scene.add(newChip);
            chips.push(newChip);

            // Create physics body for chip
            const chipShape = new CANNON.Sphere(0.5); // Match the visual size
            const chipMat = new CANNON.Material({
                friction: 0.2,
                restitution: 0.5 // Slightly bouncy
            });
            
            const newChipBody = new CANNON.Body({ 
                mass: 1,
                material: chipMat,
                linearDamping: 0.2, // Reduced damping for more natural movement
                angularDamping: 0.2,
                allowSleep: true,
                sleepSpeedLimit: 0.1, // Lower sleep speed limit for better detection
                sleepTimeLimit: 1 // Chips will sleep sooner when they stop moving
            });
            
            newChipBody.addShape(chipShape);
            newChipBody.position.set(xOffset, 9, 0); // Higher starting position
            
            // Add initial velocity variation
            newChipBody.velocity.set(
                (Math.random() - 0.5) * 1.5, // Increased random x velocity
                -1.5,                         // Increased initial downward velocity
                0
            );
            
            // Constrain the chip to the z-axis to prevent it from moving too far forward or backward
            newChipBody.addEventListener("collide", function(e) {
                // Reset z velocity on collision to prevent z-axis movement
                newChipBody.velocity.z *= 0.5;
                
                // Keep z position close to 0
                if (Math.abs(newChipBody.position.z) > 0.3) {
                    newChipBody.position.z *= 0.5;
                }
            });
            
            // Add a unique ID to track this chip
            const chipId = Date.now() + Math.random();
            newChipBody.userData = { id: chipId, scored: false };
            newChip.userData = { id: chipId };
            
            world.addBody(newChipBody);
            chipBodies.push(newChipBody);
            
            // Add event listener for this specific chip
            newChipBody.addEventListener("sleep", function() {
                onChipStop(newChipBody);
            });
            
            // Create contact materials for chip-to-peg and chip-to-chip collisions
            pegBodies.forEach(pegBody => {
                const chipPegContact = new CANNON.ContactMaterial(
                    chipMat, 
                    pegBody.material, 
                    { friction: 0.2, restitution: 0.7 }
                );
                world.addContactMaterial(chipPegContact);
            });
            
            // Create chip-to-chip contact material for existing chips
            chipBodies.forEach(existingChipBody => {
                if (existingChipBody !== newChipBody) {
                    const chipChipContact = new CANNON.ContactMaterial(
                        chipMat, 
                        existingChipBody.material, 
                        { friction: 0.4, restitution: 0.6 }
                    );
                    world.addContactMaterial(chipChipContact);
                }
            });
            
            activeChips++;
            return { chip: newChip, body: newChipBody };
        }

        function dropChip() {
            // Allow unlimited chip dropping - remove the limit
            createChip();
            document.getElementById('lastScore').textContent = "";
        }

        function resetScore() {
            totalScore = 0;
            document.getElementById('scoreDisplay').textContent = "Total Score: 0";
            document.getElementById('lastScore').textContent = "";
        }

        function onChipStop(stoppedChipBody) {
            // Only process chips that haven't been scored yet
            if (stoppedChipBody.userData && !stoppedChipBody.userData.scored && 
                stoppedChipBody.sleepState === CANNON.Body.SLEEPING) {
                
                const y = stoppedChipBody.position.y;
                
                // Only score if the chip is near the bottom (in a slot)
                if (y < -5.5) {
                    scoreChip(stoppedChipBody);
                }
            }
        }
        
        // Function to score a chip
        function scoreChip(chipBody) {
            if (chipBody.userData && !chipBody.userData.scored) {
                const x = chipBody.position.x;
                
                // Calculate which slot the chip is in
                let slotIndex = Math.floor((x + 9) / 3); // Adjusted for wider slots and board
                
                // Ensure slot index is within bounds
                slotIndex = Math.max(0, Math.min(slotScores.length - 1, slotIndex));
                const score = slotScores[slotIndex];
                
                // Update the score
                totalScore += score;
                document.getElementById('scoreDisplay').textContent = "Total Score: " + totalScore;
                document.getElementById('lastScore').textContent = "Last drop: " + score + " points!";
                
                // Add particle effect for fun
                createParticles(chipBody.position.x, chipBody.position.y, chipBody.position.z);
                
                // Mark this chip as scored so we don't count it again
                chipBody.userData.scored = true;
                
                // Flash the slot that was hit
                flashSlot(slotIndex);
                
                activeChips--;
                
                // Find the corresponding visual chip and remove it after scoring
                for (let i = 0; i < chipBodies.length; i++) {
                    if (chipBodies[i] === chipBody) {
                        // Remove the chip from the scene after a short delay
                        setTimeout(() => {
                            if (i < chips.length) {
                                scene.remove(chips[i]);
                                world.remove(chipBodies[i]);
                                chips.splice(i, 1);
                                chipBodies.splice(i, 1);
                            }
                        }, 500); // Short delay to allow particles to show
                        break;
                    }
                }
            }
        }
        
        // Function to flash a slot when it's hit
        function flashSlot(slotIndex) {
            if (slotIndex >= 0 && slotIndex < slotMeshes.length) {
                const slot = slotMeshes[slotIndex];
                const originalColor = slot.material.color.getHex();
                const originalOpacity = slot.material.opacity;
                
                // Flash white with higher opacity
                slot.material.color.set(0xFFFFFF);
                slot.material.opacity = 1.0;
                
                // Return to original color after 300ms
                setTimeout(() => {
                    slot.material.color.setHex(originalColor);
                    slot.material.opacity = originalOpacity;
                }, 300);
            }
        }
        
        // Function to remove old chips that have settled
        function cleanupOldChips() {
            // Keep maximum 15 chips in the scene for performance
            if (chips.length > 15) {
                // Remove the oldest chip
                const oldestChip = chips.shift();
                const oldestChipBody = chipBodies.shift();
                
                if (oldestChip && oldestChipBody) {
                    scene.remove(oldestChip);
                    world.remove(oldestChipBody);
                }
            }
        }

        function createParticles(x, y, z) {
            const particleCount = 30; // Increased particle count
            const particleGroup = new THREE.Group();
            scene.add(particleGroup);
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: Math.random() * 0xffffff,
                    transparent: true,
                    opacity: 0.8
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(x, y, z);
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5, // Increased spread
                        Math.random() * 0.3,         // Increased upward velocity
                        (Math.random() - 0.5) * 0.5  // Increased spread
                    ),
                    life: 40 // Increased life for longer effect
                };
                
                particleGroup.add(particle);
            }
            
            // Create a function to animate and remove particles
            function animateParticles() {
                let hasActiveParticles = false;
                
                particleGroup.children.forEach(particle => {
                    if (particle.userData.life > 0) {
                        particle.position.add(particle.userData.velocity);
                        particle.userData.velocity.y -= 0.01; // Gravity effect
                        particle.userData.life--;
                        particle.material.opacity = particle.userData.life / 40;
                        hasActiveParticles = true;
                    }
                });
                
                if (hasActiveParticles) {
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(particleGroup);
                }
            }
            
            animateParticles();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Step the physics world
            world.step(1/60);
            
            // Update all chips position from physics
            for (let i = 0; i < chips.length; i++) {
                if (i < chipBodies.length) {
                    chips[i].position.copy(chipBodies[i].position);
                    chips[i].quaternion.copy(chipBodies[i].quaternion);
                    
                    // Check if any chip has fallen too far behind the board
                    if (Math.abs(chipBodies[i].position.z) > 0.6) {
                        // Reset z position to prevent falling behind or in front
                        chipBodies[i].position.z = 0;
                        chipBodies[i].velocity.z = 0;
                    }
                    
                    // Check if any chip has fallen off the board
                    if (chipBodies[i].position.y < -10) {
                        // Remove chips that fall too far down
                        scene.remove(chips[i]);
                        world.remove(chipBodies[i]);
                        chips.splice(i, 1);
                        chipBodies.splice(i, 1);
                        i--;
                    }
                }
            }
            
            renderer.render(scene, camera);
        }

        // Function to update slot label positions on window resize
        function updateSlotLabelPositions() {
            const slotWidth = 3; // Match the wider slots
            const totalSlots = 6;
            
            for (let i = 0; i < totalSlots; i++) {
                const x = (i * slotWidth) - ((totalSlots - 1) * slotWidth / 2);
                const label = document.getElementById('slot-label-' + i);
                if (label) {
                    label.style.left = (window.innerWidth / 2) + (x * 40) - 30 + 'px';
                    label.style.top = (window.innerHeight / 2) + 270 + 'px'; // Adjusted position
                }
            }
        }

        // Initialize the game when page loads
        window.onload = init;
    </script>
</body>
</html>